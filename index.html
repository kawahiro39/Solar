<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>太陽光簡易シミュレーションシステム</title>
    <style>
        /* Global Styles */
        body {
            font-family: sans-serif;
            margin: 0;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="map-container" style="height: 100vh;"></div>
    <div id="controls">
        <button id="to-design-btn" style="display: none;">設計画面へ</button>
    </div>
    <div id="design-container" style="display: none; padding: 10px;">
        <h2>設計画面</h2>
        <div id="design-controls">
            <label for="azimuth-input">方位 (°):</label>
            <input type="number" id="azimuth-input" value="180">
            <label for="pitch-input">傾斜 (°):</label>
            <input type="number" id="pitch-input" value="30">
            <label for="offset-input">オフセット (m):</label>
            <input type="number" id="offset-input" value="0.2" step="0.1">
            <button id="auto-correct-btn">自動補正</button>
        </div>
        <div id="panel-controls">
            <label for="panel-select">パネル選択:</label>
            <select id="panel-select">
                <option value="CS6.2-48TM-455">CS6.2-48TM-455 (455W)</option>
                <option value="CS6.2-36TM-340">CS6.2-36TM-340 (340W)</option>
                <option value="CS6.2-32TM-300">CS6.2-32TM-300 (300W)</option>
            </select>
            <button id="auto-place-btn">パネルを自動配置</button>
        </div>
        <canvas id="design-canvas" style="border: 1px solid black;"></canvas>
    </div>
    <div id="results-container" style="padding: 10px;">
        <h2>シミュレーション結果</h2>
        <ul id="results-list">
            <li>設置パネル枚数: <span id="panel-count">0</span> 枚</li>
            <li>年間想定発電量: <span id="yearly-energy">0</span> kWh</li>
        </ul>
        <button id="download-pdf-btn">PDFをダウンロード</button>
    </div>

    <!-- Libraries for PDF Generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>

    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDmrtd9_lCHwfRIysJ4q7q0gaZvGxbmPtc&callback=initMap&libraries=drawing,geometry&v=weekly" defer></script>
    <script>
        // Global variables
        let map;
        let drawingManager;
        let roofPolygons = [];

        // Initialize the map
        function initMap() {
            const mapOptions = {
                center: { lat: 35.6895, lng: 139.6917 },
                zoom: 18,
                mapTypeId: 'satellite',
                disableDefaultUI: true,
                tilt: 0, // Disable 45-degree tilt
            };

            map = new google.maps.Map(document.getElementById('map-container'), mapOptions);

            drawingManager = new google.maps.drawing.DrawingManager({
                drawingMode: google.maps.drawing.OverlayType.POLYGON,
                drawingControl: true,
                drawingControlOptions: {
                    position: google.maps.ControlPosition.TOP_CENTER,
                    drawingModes: [google.maps.drawing.OverlayType.POLYGON],
                },
                polygonOptions: {
                    fillColor: '#FF0000',
                    fillOpacity: 0.5,
                    strokeWeight: 2,
                    strokeColor: '#FF0000',
                    editable: true,
                    draggable: true,
                },
            });

            drawingManager.setMap(map);

            google.maps.event.addListener(drawingManager, 'polygoncomplete', function (polygon) {
                roofPolygons.push(polygon);
                // After drawing one, the user can draw another. Drawing mode remains active.
                document.getElementById('to-design-btn').style.display = 'block';
            });
        }

        function toDesignView() {
            if (roofPolygons.length === 0) return;
            document.getElementById('map-container').style.display = 'none';
            document.getElementById('controls').style.display = 'none';
            // Find and hide all Google Maps controls
            document.querySelectorAll('.gmnoprint').forEach(el => el.style.display = 'none');
            document.getElementById('design-container').style.display = 'block';

            // Handle multiple polygons
            const allCoordinates = roofPolygons.map(polygon => {
                const path = polygon.getPath();
                return path.getArray().map(p => ({ lat: p.lat(), lng: p.lng() }));
            });
            drawPolygonsOnCanvas(allCoordinates);
        }

        const panelData = {
            "CS6.2-48TM-455": { width: 1.134, height: 2.024 },
            "CS6.2-36TM-340": { width: 1.134, height: 1.520 },
            "CS6.2-32TM-300": { width: 1.134, height: 1.352 }
        };

        let roofObjects = []; // Array to hold { geoCoords, canvasPoints, ... } for each roof
        let selectedRoofIndex = -1;
        let selectedPointIndex = -1;
        let isDragging = false;
        const pointHitRadius = 10;
        let geoToCanvasScale = 1;
        let solarData = null;

        function drawPolygonsOnCanvas(allCoordinates) {
            const canvas = document.getElementById('design-canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 800; // Increase canvas size for multiple roofs
            canvas.height = 600;

            // Find the bounding box of ALL polygons
            let masterMinLng = Infinity, masterMaxLng = -Infinity;
            let masterMinLat = Infinity, masterMaxLat = -Infinity;
            allCoordinates.forEach(polygonCoords => {
                polygonCoords.forEach(c => {
                    masterMinLng = Math.min(masterMinLng, c.lng);
                    masterMaxLng = Math.max(masterMaxLng, c.lng);
                    masterMinLat = Math.min(masterMinLat, c.lat);
                    masterMaxLat = Math.max(masterMaxLat, c.lat);
                });
            });

            // Calculate scale to fit all polygons
            const padding = 20;
            const scaleX = (canvas.width - 2 * padding) / (masterMaxLng - masterMinLng);
            const scaleY = (canvas.height - 2 * padding) / (masterMaxLat - masterMinLat);
            const scale = Math.min(scaleX, scaleY);

            // Calculate rotation to make North point up
            const north = google.maps.geometry.spherical.computeOffset(new google.maps.LatLng(masterMaxLat, masterMinLng), 1, 0);
            const p1 = { x: 0, y: 0 }; // map point (0,0) for heading calculation
            const p2 = { x: north.lng() - masterMinLng, y: north.lat() - masterMaxLat }; // vector pointing north
            const rotationAngle = Math.atan2(p2.y, p2.x) + Math.PI / 2;

            const centerPoint = {
                x: padding + ((masterMaxLng - masterMinLng) / 2) * scale,
                y: padding + ((masterMaxLat - masterMinLat) / 2) * scale,
            };

            geoToCanvasScale = scale / google.maps.geometry.spherical.computeDistanceBetween(
                 new google.maps.LatLng(masterMinLat, masterMinLng),
                 new google.maps.LatLng(masterMinLat, masterMinLng + 1)
            ); // This gives an approximate pixels/degree scale, then needs conversion to meters

            roofObjects = allCoordinates.map((coords, index) => {
                const canvasPoints = coords.map(c => {
                    const initialX = padding + (c.lng - masterMinLng) * scale;
                    const initialY = padding + (masterMaxLat - c.lat) * scale;
                    // Rotate point around the center of the bounding box
                    const translatedX = initialX - centerPoint.x;
                    const translatedY = initialY - centerPoint.y;
                    const rotatedX = translatedX * Math.cos(-rotationAngle) - translatedY * Math.sin(-rotationAngle);
                    const rotatedY = translatedX * Math.sin(-rotationAngle) + translatedY * Math.cos(-rotationAngle);
                    return { x: rotatedX + centerPoint.x, y: rotatedY + centerPoint.y };
                });
                return {
                    id: index,
                    geoCoords: coords,
                    canvasPoints: canvasPoints,
                    placedPanels: [],
                    eaveEdgeIndex: null, // To be set by user click
                };
            });

            redrawCanvas();
        }

        function redrawCanvas() {
            const canvas = document.getElementById('design-canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            roofObjects.forEach((roof, index) => {
                const points = roof.canvasPoints;
                if (points.length === 0) return;

                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                points.forEach(p => ctx.lineTo(p.x, p.y));
                ctx.closePath();
                ctx.fillStyle = (index === selectedRoofIndex) ? "rgba(200, 200, 255, 0.7)" : "rgba(200, 200, 200, 0.7)";
                ctx.fill();
                ctx.strokeStyle = "black";
                ctx.lineWidth = 2;
                ctx.stroke();

                // Highlight the selected eave
                if (roof.eaveEdgeIndex !== null) {
                    const p1 = roof.canvasPoints[roof.eaveEdgeIndex];
                    const p2 = roof.canvasPoints[(roof.eaveEdgeIndex + 1) % roof.canvasPoints.length];
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.strokeStyle = "green";
                    ctx.lineWidth = 4;
                    ctx.stroke();
                }

                // Draw the offset polygon
                const offsetDistance = parseFloat(document.getElementById('offset-input').value) * geoToCanvasScale;
                const offsetPoints = getOffsetPolygon(points, -offsetDistance);
                if (offsetPoints.length > 2) {
                    ctx.beginPath();
                    ctx.moveTo(offsetPoints[0].x, offsetPoints[0].y);
                    offsetPoints.forEach(p => ctx.lineTo(p.x, p.y));
                    ctx.closePath();
                    ctx.strokeStyle = "blue";
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }


                // Draw panels for this roof
                ctx.strokeStyle = 'blue';
                roof.placedPanels.forEach(panel => {
                    ctx.beginPath();
                    ctx.moveTo(panel[0].x, panel[0].y);
                    for (let i = 1; i < panel.length; i++) ctx.lineTo(panel[i].x, panel[i].y);
                    ctx.closePath();
                    ctx.stroke();
                });

                // Draw vertices only for the selected roof
                if (index === selectedRoofIndex) {
                    ctx.fillStyle = 'red';
                    points.forEach(p => {
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, pointHitRadius / 2, 0, 2 * Math.PI);
                        ctx.fill();
                    });
                }
            });
        }

        function handleMouseDown(e) {
            const rect = e.target.getBoundingClientRect();
            const mouseX = e.clientX - rect.left, mouseY = e.clientY - rect.top;

            // First, check if we are clicking inside any polygon to select it
            let clickedRoof = false;
            for (let i = roofObjects.length - 1; i >= 0; i--) {
                if (isPointInPolygon({x: mouseX, y: mouseY}, roofObjects[i].canvasPoints)) {
                    selectedRoofIndex = i;
                    clickedRoof = true;
                    break;
                }
            }
            if(!clickedRoof) selectedRoofIndex = -1;


            // If a roof is selected, check if we are clicking a vertex on it
            if (selectedRoofIndex !== -1) {
                const selectedRoof = roofObjects[selectedRoofIndex];
                selectedPointIndex = selectedRoof.canvasPoints.findIndex(p => Math.hypot(mouseX - p.x, mouseY - p.y) < pointHitRadius);
                if (selectedPointIndex !== -1) {
                    isDragging = true;
                    redrawCanvas();
                    return; // Don't check for edge clicks if a vertex is clicked
                }

                // If not a vertex, check for an edge click to set the eave
                for (let i = 0; i < selectedRoof.canvasPoints.length; i++) {
                    const p1 = selectedRoof.canvasPoints[i];
                    const p2 = selectedRoof.canvasPoints[(i + 1) % selectedRoof.canvasPoints.length];
                    // Simple distance to line segment check
                    const dist = distToSegment({x: mouseX, y: mouseY}, p1, p2);
                    if (dist < pointHitRadius) {
                        selectedRoof.eaveEdgeIndex = i;
                        break;
                    }
                }
            } else {
                 selectedPointIndex = -1;
            }
            redrawCanvas();
        }

        function distToSegment(p, v, w) {
            const l2 = (v.x - w.x)**2 + (v.y - w.y)**2;
            if (l2 === 0) return Math.hypot(p.x - v.x, p.y - v.y);
            let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            return Math.hypot(p.x - (v.x + t * (w.x - v.x)), p.y - (v.y + t * (w.y - v.y)));
        }

        function handleMouseMove(e) {
            if (isDragging && selectedRoofIndex !== -1 && selectedPointIndex !== -1) {
                const rect = e.target.getBoundingClientRect();
                roofObjects[selectedRoofIndex].canvasPoints[selectedPointIndex].x = e.clientX - rect.left;
                roofObjects[selectedRoofIndex].canvasPoints[selectedPointIndex].y = e.clientY - rect.top;
                redrawCanvas();
            }
        }

        function handleMouseUp() { isDragging = false; }

        function autoCorrectPolygon() {
            if (selectedRoofIndex === -1) {
                alert("Please select a roof area to correct.");
                return;
            }
            const roof = roofObjects[selectedRoofIndex];
            const points = roof.canvasPoints;
            if (points.length < 3) return;

            const corrected = JSON.parse(JSON.stringify(points));
            for (let i = 0; i < corrected.length; i++) {
                const p0 = corrected[(i + corrected.length - 1) % corrected.length];
                const p1 = corrected[i];
                const p2 = corrected[(i + 1) % corrected.length];
                const v1 = { x: p0.x - p1.x, y: p0.y - p1.y };
                const v2 = { x: p2.x - p1.x, y: p2.y - p1.y };
                const angle = Math.abs((Math.atan2(v2.y, v2.x) - Math.atan2(v1.y, v1.x)) * 180 / Math.PI);
                if (Math.abs((angle > 180 ? 360 - angle : angle) - 90) < 7) {
                    const v1_len = Math.hypot(v1.x, v1.y), v_perp = { x: -v1.y, y: v1.x };
                    if (v2.x * v_perp.x + v2.y * v_perp.y < 0) { v_perp.x *= -1; v_perp.y *= -1; }
                    const v_perp_norm = { x: v_perp.x / v1_len, y: v_perp.y / v1_len };
                    const v2_len = Math.hypot(v2.x, v2.y);
                    corrected[(i + 1) % corrected.length] = { x: p1.x + v_perp_norm.x * v2_len, y: p1.y + v_perp_norm.y * v2_len };
                }
            }
            roof.canvasPoints = corrected;
            redrawCanvas();
        }

        function autoPlacePanels() {
            if (selectedRoofIndex === -1 || roofObjects[selectedRoofIndex].eaveEdgeIndex === null) {
                alert("Please select a roof and define its eave (panel placement starting edge) by clicking on an edge.");
                return;
            }
            const roof = roofObjects[selectedRoofIndex];
            const canvasPoints = roof.canvasPoints;
            const panel = panelData[document.getElementById('panel-select').value];
            const panelWidth = panel.width * geoToCanvasScale;
            const panelHeight = panel.height * geoToCanvasScale;

            const offsetDistance = parseFloat(document.getElementById('offset-input').value) * geoToCanvasScale;
            const placementPolygon = getOffsetPolygon(canvasPoints, -offsetDistance);

            if (placementPolygon.length < 3) {
                roof.placedPanels = [];
                redrawCanvas();
                return;
            }

            const eaveIndex = roof.eaveEdgeIndex;
            const p1 = placementPolygon[eaveIndex]; // Start from the offset polygon's eave
            const p2 = placementPolygon[(eaveIndex + 1) % placementPolygon.length];

            const eaveVector = { x: p2.x - p1.x, y: p2.y - p1.y };
            const eaveLength = Math.hypot(eaveVector.x, eaveVector.y);
            const angle = Math.atan2(eaveVector.y, eaveVector.x);

            let upVector = { x: -eaveVector.y, y: eaveVector.x };
            const testPoint = { x: p1.x + eaveVector.x / 2 + upVector.x * 0.1, y: p1.y + eaveVector.y/2 + upVector.y * 0.1 };
            if (!isPointInPolygon(testPoint, placementPolygon)) {
                upVector = { x: eaveVector.y, y: -eaveVector.x };
            }
            const upVectorLength = Math.hypot(upVector.x, upVector.y);
            const upVectorNorm = { x: upVector.x / upVectorLength, y: upVector.y / upVectorLength };

            const placedPanels = [];
            const boundingBox = placementPolygon.reduce((b, p) => ({ minX: Math.min(b.minX, p.x), maxX: Math.max(b.maxX, p.x), minY: Math.min(b.minY, p.y), maxY: Math.max(b.maxY, p.y) }), { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity });
            const maxDist = Math.hypot(boundingBox.maxX - boundingBox.minX, boundingBox.maxY - boundingBox.minY);

            for (let y = 0; y < maxDist; y += panelHeight) {
                for (let x = 0; x < eaveLength; x += panelWidth) {
                    const startPoint = {
                        x: p1.x + (eaveVector.x / eaveLength) * x + upVectorNorm.x * y,
                        y: p1.y + (eaveVector.y / eaveLength) * x + upVectorNorm.y * y
                    };
                    const corners = [
                        { x: 0, y: 0 }, { x: panelWidth, y: 0 },
                        { x: panelWidth, y: panelHeight }, { x: 0, y: panelHeight }
                    ].map(p => {
                        const rotatedX = p.x * Math.cos(angle) - p.y * Math.sin(angle);
                        const rotatedY = p.x * Math.sin(angle) + p.y * Math.cos(angle);
                        return { x: startPoint.x + rotatedX, y: startPoint.y + rotatedY };
                    });

                    if (corners.every(c => isPointInPolygon(c, placementPolygon))) {
                        placedPanels.push(corners);
                    }
                }
            }

            roof.placedPanels = placedPanels;
            redrawCanvas();
        }

        function getOffsetPolygon(points, offset) {
            const offsetPoints = [];
            const numPoints = points.length;
            for (let i = 0; i < numPoints; i++) {
                const p1 = points[i];
                const p2 = points[(i + 1) % numPoints];
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const len = Math.hypot(dx, dy);
                const normal = { x: -dy / len, y: dx / len };
                offsetPoints.push({
                    x1: p1.x + offset * normal.x,
                    y1: p1.y + offset * normal.y,
                    x2: p2.x + offset * normal.x,
                    y2: p2.y + offset * normal.y
                });
            }

            const newPolygon = [];
            for (let i = 0; i < numPoints; i++) {
                const line1 = offsetPoints[i];
                const line2 = offsetPoints[(i + numPoints - 1) % numPoints];
                const intersection = intersectLines(line1.x1, line1.y1, line1.x2, line1.y2, line2.x1, line2.y1, line2.x2, line2.y2);
                if (intersection) {
                    newPolygon.unshift(intersection);
                }
            }
            return newPolygon;
        }

        function intersectLines(x1, y1, x2, y2, x3, y3, x4, y4) {
            const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            if (den === 0) return null; // Parallel
            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;
            const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / den;
            if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
                return { x: x1 + t * (x2 - x1), y: y1 + t * (y2 - y1) };
            }
            return { x: x1 + t * (x2 - x1), y: y1 + t * (y2 - y1) }; // Return intersection even if outside segment
        }


        function isPointInPolygon(point, polygon) {
            let isInside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                if (((polygon[i].y > point.y) !== (polygon[j].y > point.y)) && (point.x < (polygon[j].x - polygon[i].x) * (point.y - polygon[i].y) / (polygon[j].y - polygon[i].y) + polygon[i].x)) {
                    isInside = !isInside;
                }
            }
            return isInside;
        }

        async function getSolarPotential(roof) {
            if (!roof) return;

            const center = { lat: roof.geoCoords[0].lat, lng: roof.geoCoords[0].lng }; // Simplified center
            const API_KEY = 'AIzaSyDmrtd9_lCHwfRIysJ4q7q0gaZvGxbmPtc';
            const url = `https://solar.googleapis.com/v1/buildingInsights:findClosest?location.latitude=${center.lat}&location.longitude=${center.lng}&requiredQuality=HIGH&key=${API_KEY}`;

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`API request failed: ${response.status}`);
                const data = await response.json();
                roof.solarData = data; // Store response on the specific roof object
                updateResults();

            } catch (error) {
                console.error(`Error fetching Solar API for roof ${roof.id}:`, error);
                alert(`太陽光発電ポテンシャルの取得に失敗しました（屋根${roof.id + 1}）。`);
            }
        }

        function updateResults() {
            let totalPanelCount = 0;
            let totalYearlyEnergy = 0;
            const panelCapacityWatts = parseFloat(document.getElementById('panel-select').value.split('-').pop());

            roofObjects.forEach(roof => {
                totalPanelCount += roof.placedPanels.length;
                if (roof.solarData && roof.solarData.solarPotential) {
                    const config = roof.solarData.solarPotential.solarPanelConfigs[0];
                    if (config) {
                        const roofEnergy = (roof.placedPanels.length * panelCapacityWatts) / (config.panelsCount * config.panelCapacityWatts) * config.yearlyEnergyDcKwh;
                        totalYearlyEnergy += roofEnergy;
                    }
                }
            });

            document.getElementById('panel-count').textContent = totalPanelCount;
            document.getElementById('yearly-energy').textContent = totalYearlyEnergy.toFixed(2);
        }

        function generatePDF() {
            const totalPanelCount = roofObjects.reduce((sum, roof) => sum + roof.placedPanels.length, 0);
            if (totalPanelCount === 0) {
                alert("Please place panels before downloading a PDF.");
                return;
            }

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            doc.text("Solar Simulation Report", 20, 20);
            const canvasImage = document.getElementById('design-canvas').toDataURL('image/png', 1.0);
            doc.addImage(canvasImage, 'PNG', 15, 40, 180, 150);
            doc.text(`Total Panel Count: ${totalPanelCount}`, 20, 200);
            doc.text(`Total Estimated Yearly Output: ${document.getElementById('yearly-energy').textContent} kWh`, 20, 210);
            doc.addPage();
            doc.text("Aggregated Monthly Energy Production (kWh)", 20, 20);

            const chartCanvas = document.createElement('canvas');
            const aggregatedMonthlyData = new Array(12).fill(0);

            roofObjects.forEach(roof => {
                 if (roof.solarData && roof.solarData.solarPotential) {
                    const config = roof.solarData.solarPotential.solarPanelConfigs[0];
                    const panelRatio = roof.placedPanels.length / config.panelsCount;
                    roof.solarData.solarPotential.monthlyFluxes.forEach((month, i) => {
                        aggregatedMonthlyData[i] += month.kWh * panelRatio;
                    });
                 }
            });
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            new Chart(chartCanvas, {
                type: 'bar',
                data: {
                    labels: ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'],
                    datasets: [{ label: '月別発電量 (kWh)', data: aggregatedMonthlyData, backgroundColor: 'rgba(54, 162, 235, 0.6)' }]
                },
                options: { animation: { onComplete: () => {
                    doc.addImage(chartCanvas.toDataURL('image/png', 1.0), 'PNG', 20, 40, 170, 85);
                    doc.save('simulation_report.pdf');
                }}}
            });
        }

        window.addEventListener('DOMContentLoaded', () => {
            document.getElementById('to-design-btn').addEventListener('click', toDesignView);
            document.getElementById('auto-correct-btn').addEventListener('click', autoCorrectPolygon);
            document.getElementById('auto-place-btn').addEventListener('click', () => {
                if (selectedRoofIndex !== -1) {
                    autoPlacePanels();
                    getSolarPotential(roofObjects[selectedRoofIndex]);
                } else {
                    alert("Please select a roof to place panels on.");
                }
            });
            document.getElementById('download-pdf-btn').addEventListener('click', generatePDF);
            const canvas = document.getElementById('design-canvas');
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseUp);
        });
    </script>
</body>
</html>