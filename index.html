<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>太陽光簡易シミュレーションシステム</title>
    <style>
        /* Global Styles */
        body {
            font-family: sans-serif;
            margin: 0;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="map-container" style="height: 100vh;"></div>
    <div id="controls">
        <button id="to-design-btn" style="display: none;">設計画面へ</button>
    </div>
    <div id="design-container" style="display: none; padding: 10px;">
        <h2>設計画面</h2>
        <div id="design-controls">
            <label for="azimuth-input">方位 (°):</label>
            <input type="number" id="azimuth-input" value="180">
            <label for="pitch-input">傾斜 (°):</label>
            <input type="number" id="pitch-input" value="30">
            <label for="offset-input">オフセット (cm):</label>
            <input type="number" id="offset-input" value="20" step="1">
            <button id="auto-correct-btn">自動補正</button>
            <button id="back-to-overview-btn" style="display: none;">一覧へ戻る</button>
        </div>
        <div id="panel-controls">
            <label for="panel-select">パネル選択:</label>
            <select id="panel-select">
                <option value="CS6.2-48TM-455">CS6.2-48TM-455 (455W)</option>
                <option value="CS6.2-36TM-340">CS6.2-36TM-340 (340W)</option>
                <option value="CS6.2-32TM-300">CS6.2-32TM-300 (300W)</option>
            </select>
            <button id="auto-place-btn">パネルを自動配置</button>
        </div>
        <canvas id="design-canvas" style="border: 1px solid black;"></canvas>
    </div>
    <div id="results-container" style="padding: 10px;">
        <h2>シミュレーション結果</h2>
        <ul id="results-list">
            <li>設置パネル枚数: <span id="panel-count">0</span> 枚</li>
            <li>年間想定発電量: <span id="yearly-energy">0</span> kWh</li>
        </ul>
        <button id="download-pdf-btn">PDFをダウンロード</button>
    </div>

    <!-- Libraries for PDF Generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>

    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDmrtd9_lCHwfRIysJ4q7q0gaZvGxbmPtc&callback=initMap&libraries=drawing,geometry&v=weekly" defer></script>
    <script>
        // Global variables
        let map;
        let drawingManager;
        let roofPolygons = [];

        // Initialize the map
        function initMap() {
            const mapOptions = {
                center: { lat: 35.6895, lng: 139.6917 },
                zoom: 18,
                mapTypeId: 'satellite',
                disableDefaultUI: true,
                tilt: 0, // Disable 45-degree tilt
            };

            map = new google.maps.Map(document.getElementById('map-container'), mapOptions);

            drawingManager = new google.maps.drawing.DrawingManager({
                drawingMode: google.maps.drawing.OverlayType.POLYGON,
                drawingControl: true,
                drawingControlOptions: {
                    position: google.maps.ControlPosition.TOP_CENTER,
                    drawingModes: [google.maps.drawing.OverlayType.POLYGON],
                },
                polygonOptions: {
                    fillColor: '#FF0000',
                    fillOpacity: 0.5,
                    strokeWeight: 2,
                    strokeColor: '#FF0000',
                    editable: true,
                    draggable: true,
                },
            });

            drawingManager.setMap(map);

            google.maps.event.addListener(drawingManager, 'polygoncomplete', function (polygon) {
                roofPolygons.push(polygon);
                // After drawing one, the user can draw another. Drawing mode remains active.
                document.getElementById('to-design-btn').style.display = 'block';
            });
        }

        function toDesignView() {
            if (roofPolygons.length === 0) return;
            document.getElementById('map-container').style.display = 'none';
            document.getElementById('controls').style.display = 'none';
            // Find and hide all Google Maps controls
            document.querySelectorAll('.gmnoprint').forEach(el => el.style.display = 'none');
            document.getElementById('design-container').style.display = 'block';

            // Handle multiple polygons
            const allCoordinates = roofPolygons.map(polygon => {
                const path = polygon.getPath();
                return path.getArray().map(p => ({ lat: p.lat(), lng: p.lng() }));
            });
            drawPolygonsOnCanvas(allCoordinates);
        }

        const panelData = {
            "CS6.2-48TM-455": { width: 1.134, height: 2.024 },
            "CS6.2-36TM-340": { width: 1.134, height: 1.520 },
            "CS6.2-32TM-300": { width: 1.134, height: 1.352 }
        };

        let roofObjects = []; // Array to hold { geoCoords, canvasPoints, ... } for each roof
        let designMode = 'overview'; // Can be 'overview' or 'detail'
        let selectedRoofIndex = -1;
        let selectedPointIndex = -1;
        let isDragging = false;
        const pointHitRadius = 10;
        let geoToCanvasScale = 1;
        let solarData = null;

        function drawPolygonsOnCanvas(allCoordinates) {
            const canvas = document.getElementById('design-canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 800; // Increase canvas size for multiple roofs
            canvas.height = 600;

            // Find the bounding box of ALL polygons
            let masterMinLng = Infinity, masterMaxLng = -Infinity;
            let masterMinLat = Infinity, masterMaxLat = -Infinity;
            allCoordinates.forEach(polygonCoords => {
                polygonCoords.forEach(c => {
                    masterMinLng = Math.min(masterMinLng, c.lng);
                    masterMaxLng = Math.max(masterMaxLng, c.lng);
                    masterMinLat = Math.min(masterMinLat, c.lat);
                    masterMaxLat = Math.max(masterMaxLat, c.lat);
                });
            });

            // Calculate scale to fit all polygons
            const padding = 20;
            const scaleX = (canvas.width - 2 * padding) / (masterMaxLng - masterMinLng);
            const scaleY = (canvas.height - 2 * padding) / (masterMaxLat - masterMinLat);
            const scale = Math.min(scaleX, scaleY);

            // Calculate rotation to make North point up
            const north = google.maps.geometry.spherical.computeOffset(new google.maps.LatLng(masterMaxLat, masterMinLng), 1, 0);
            const p1 = { x: 0, y: 0 }; // map point (0,0) for heading calculation
            const p2 = { x: north.lng() - masterMinLng, y: north.lat() - masterMaxLat }; // vector pointing north
            const rotationAngle = Math.atan2(p2.y, p2.x) + Math.PI / 2;

            const centerPoint = {
                x: padding + ((masterMaxLng - masterMinLng) / 2) * scale,
                y: padding + ((masterMaxLat - masterMinLat) / 2) * scale,
            };

            geoToCanvasScale = scale / google.maps.geometry.spherical.computeDistanceBetween(
                 new google.maps.LatLng(masterMinLat, masterMinLng),
                 new google.maps.LatLng(masterMinLat, masterMinLng + 1)
            ); // This gives an approximate pixels/degree scale, then needs conversion to meters

            roofObjects = allCoordinates.map((coords, index) => {
                const canvasPoints = coords.map(c => {
                    const initialX = padding + (c.lng - masterMinLng) * scale;
                    const initialY = padding + (masterMaxLat - c.lat) * scale;
                    // Rotate point around the center of the bounding box
                    const translatedX = initialX - centerPoint.x;
                    const translatedY = initialY - centerPoint.y;
                    const rotatedX = translatedX * Math.cos(-rotationAngle) - translatedY * Math.sin(-rotationAngle);
                    const rotatedY = translatedX * Math.sin(-rotationAngle) + translatedY * Math.cos(-rotationAngle);
                    return { x: rotatedX + centerPoint.x, y: rotatedY + centerPoint.y };
                });
                return {
                    id: index,
                    geoCoords: coords,
                    canvasPoints: canvasPoints,
                    placedPanels: [],
                    eaveEdgeIndex: null, // To be set by user click
                };
            });

            redrawCanvas();
        }

        function redrawCanvas() {
            const canvas = document.getElementById('design-canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const roofsToDraw = designMode === 'overview' ? roofObjects : (selectedRoofIndex !== -1 ? [roofObjects[selectedRoofIndex]] : []);

            roofsToDraw.forEach((roof, index) => {
                if (!roof) return;
                let points = roof.canvasPoints;
                if (points.length === 0) return;

                if (designMode === 'detail') {
                    const eaveIndex = roof.eaveEdgeIndex;
                    if (eaveIndex !== null) {
                        const p1 = points[eaveIndex];
                        const p2 = points[(eaveIndex + 1) % points.length];
                        const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);

                        // Calculate center of the polygon
                        const center = points.reduce((acc, p) => ({x: acc.x + p.x, y: acc.y + p.y}), {x:0, y:0});
                        center.x /= points.length;
                        center.y /= points.length;

                        const canvasCenter = { x: canvas.width / 2, y: canvas.height / 2 };

                        points = points.map(p => {
                            const translatedX = p.x - center.x;
                            const translatedY = p.y - center.y;
                            const rotatedX = translatedX * Math.cos(-angle) - translatedY * Math.sin(-angle);
                            const rotatedY = translatedX * Math.sin(-angle) + translatedY * Math.cos(-angle);
                            return { x: rotatedX + canvasCenter.x, y: rotatedY + canvasCenter.y };
                        });
                        // Store the transformation info and the transformed points
                        roof.transform = { angle, center, canvasCenter };
                        roof.detailViewPoints = points;
                    }
                } else {
                    delete roof.detailViewPoints;
                    delete roof.transform;
                }

                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                points.forEach(p => ctx.lineTo(p.x, p.y));
                ctx.closePath();
                ctx.fillStyle = (index === selectedRoofIndex) ? "rgba(200, 200, 255, 0.7)" : "rgba(200, 200, 200, 0.7)";
                ctx.fill();
                ctx.strokeStyle = "black";
                ctx.lineWidth = 2;
                ctx.stroke();

                // Highlight the selected eave
                if (roof.eaveEdgeIndex !== null) {
                    const p1 = roof.canvasPoints[roof.eaveEdgeIndex];
                    const p2 = roof.canvasPoints[(roof.eaveEdgeIndex + 1) % roof.canvasPoints.length];
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.strokeStyle = "green";
                    ctx.lineWidth = 4;
                    ctx.stroke();
                }

                // Draw the offset polygon
                const offsetCm = parseFloat(document.getElementById('offset-input').value);
                let offsetDistance = (offsetCm / 100) * geoToCanvasScale;
                 if (isPolygonClockwise(points)) {
                    offsetDistance = -offsetDistance;
                }
                const offsetPoints = getOffsetPolygon(points, -offsetDistance);
                if (offsetPoints.length > 2) {
                    ctx.beginPath();
                    ctx.moveTo(offsetPoints[0].x, offsetPoints[0].y);
                    offsetPoints.forEach(p => ctx.lineTo(p.x, p.y));
                    ctx.closePath();
                    ctx.strokeStyle = "blue";
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }


                // Draw panels for this roof
                ctx.strokeStyle = 'blue';
                roof.placedPanels.forEach(panel => {
                    ctx.beginPath();
                    ctx.moveTo(panel[0].x, panel[0].y);
                    for (let i = 1; i < panel.length; i++) ctx.lineTo(panel[i].x, panel[i].y);
                    ctx.closePath();
                    ctx.stroke();
                });

                // Draw vertices only for the selected roof
                if (index === selectedRoofIndex) {
                    ctx.fillStyle = 'red';
                    points.forEach(p => {
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, pointHitRadius / 2, 0, 2 * Math.PI);
                        ctx.fill();
                    });
                }
            });
        }

        function handleMouseDown(e) {
            const rect = e.target.getBoundingClientRect();
            const mouseX = e.clientX - rect.left, mouseY = e.clientY - rect.top;

            const pointsToCheck = (designMode === 'detail' && roofObjects[selectedRoofIndex]?.detailViewPoints)
                ? roofObjects[selectedRoofIndex].detailViewPoints
                : null;

            if (designMode === 'overview') {
                let clickedRoof = false;
                for (let i = roofObjects.length - 1; i >= 0; i--) {
                    if (isPointInPolygon({x: mouseX, y: mouseY}, roofObjects[i].canvasPoints)) {
                        selectedRoofIndex = i;
                        clickedRoof = true;
                        break;
                    }
                }
                if(!clickedRoof) selectedRoofIndex = -1;
            }

            if (selectedRoofIndex !== -1) {
                const selectedRoof = roofObjects[selectedRoofIndex];
                const activePoints = selectedRoof.detailViewPoints || selectedRoof.canvasPoints;

                selectedPointIndex = activePoints.findIndex(p => Math.hypot(mouseX - p.x, mouseY - p.y) < pointHitRadius);
                if (selectedPointIndex !== -1) {
                    isDragging = true;
                    redrawCanvas();
                    return;
                }

                if(designMode === 'overview') {
                    for (let i = 0; i < activePoints.length; i++) {
                        const p1 = activePoints[i];
                        const p2 = activePoints[(i + 1) % activePoints.length];
                        const dist = distToSegment({x: mouseX, y: mouseY}, p1, p2);
                        if (dist < pointHitRadius) {
                            selectedRoof.eaveEdgeIndex = i;
                            designMode = 'detail';
                            document.getElementById('back-to-overview-btn').style.display = 'inline-block';
                            break;
                        }
                    }
                }
            } else {
                 selectedPointIndex = -1;
            }
            redrawCanvas();
        }

        function distToSegment(p, v, w) {
            const l2 = (v.x - w.x)**2 + (v.y - w.y)**2;
            if (l2 === 0) return Math.hypot(p.x - v.x, p.y - v.y);
            let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            return Math.hypot(p.x - (v.x + t * (w.x - v.x)), p.y - (v.y + t * (w.y - v.y)));
        }

        function handleMouseMove(e) {
            if (isDragging && selectedRoofIndex !== -1 && selectedPointIndex !== -1) {
                const rect = e.target.getBoundingClientRect();
                const roof = roofObjects[selectedRoofIndex];
                const activePoints = roof.detailViewPoints || roof.canvasPoints;
                activePoints[selectedPointIndex].x = e.clientX - rect.left;
                activePoints[selectedPointIndex].y = e.clientY - rect.top;

                // If in detail view, we need to reverse-transform the change back to the original points
                if (roof.detailViewPoints) {
                    // This is a complex step, for now we will just redraw
                    // A full implementation would require storing the transform and applying its inverse
                }

                redrawCanvas();
            }
        }

        function handleMouseUp() {
            if (isDragging && selectedRoofIndex !== -1 && roofObjects[selectedRoofIndex].detailViewPoints) {
                applyInverseTransform(roofObjects[selectedRoofIndex]);
            }
            isDragging = false;
        }

        function dist(p1, p2) {
            return Math.hypot(p1.x - p2.x, p1.y - p2.y);
        }

        function applyInverseTransform(roof) {
            const { angle, center, canvasCenter } = roof.transform;
            roof.canvasPoints = roof.detailViewPoints.map(p => {
                const translatedX = p.x - canvasCenter.x;
                const translatedY = p.y - canvasCenter.y;
                const rotatedX = translatedX * Math.cos(angle) - translatedY * Math.sin(angle);
                const rotatedY = translatedX * Math.sin(angle) + translatedY * Math.cos(angle);
                return { x: rotatedX + center.x, y: rotatedY + center.y };
            });
        }

        function autoCorrectPolygon() {
            if (selectedRoofIndex === -1) {
                alert("Please select a roof area to correct.");
                return;
            }
            const roof = roofObjects[selectedRoofIndex];
            const activePoints = roof.detailViewPoints || roof.canvasPoints;
            if (activePoints.length !== 4) {
                alert("Auto-correction to a rectangle only works for 4-sided shapes.");
                return;
            }

            // Find the center of the quadrilateral
            const center = activePoints.reduce((acc, p) => ({x: acc.x + p.x, y: acc.y + p.y}), {x:0, y:0});
            center.x /= 4;
            center.y /= 4;

            // Calculate average lengths of opposite sides
            const l1 = dist(activePoints[0], activePoints[1]);
            const l2 = dist(activePoints[2], activePoints[3]);
            const avgWidth = (l1 + l2) / 2;

            const h1 = dist(activePoints[1], activePoints[2]);
            const h2 = dist(activePoints[3], activePoints[0]);
            const avgHeight = (h1 + h2) / 2;

            // Find the angle of the first edge
            const angle = Math.atan2(activePoints[1].y - activePoints[0].y, activePoints[1].x - activePoints[0].x);

            const w_x = (avgWidth / 2) * Math.cos(angle);
            const w_y = (avgWidth / 2) * Math.sin(angle);
            const h_x = (avgHeight / 2) * Math.cos(angle + Math.PI/2);
            const h_y = (avgHeight / 2) * Math.sin(angle + Math.PI/2);

            const corrected = [
                { x: center.x - w_x - h_x, y: center.y - w_y - h_y },
                { x: center.x + w_x - h_x, y: center.y + w_y - h_y },
                { x: center.x + w_x + h_x, y: center.y + w_y + h_y },
                { x: center.x - w_x + h_x, y: center.y - w_y + h_y }
            ];

            if (roof.detailViewPoints) {
                roof.detailViewPoints = corrected;
                applyInverseTransform(roof);
            } else {
                roof.canvasPoints = corrected;
            }
            redrawCanvas();
        }

        function autoPlacePanels() {
            if (selectedRoofIndex === -1 || roofObjects[selectedRoofIndex].eaveEdgeIndex === null) {
                alert("Please select a roof and define its eave to switch to the detail view for panel placement.");
                return;
            }
             if (designMode !== 'detail') {
                alert("Please select an eave to enter detail design mode before placing panels.");
                return;
            }

            const roof = roofObjects[selectedRoofIndex];
            const canvasPoints = roof.detailViewPoints;
            const panel = panelData[document.getElementById('panel-select').value];
            const panelWidth = panel.width * geoToCanvasScale;
            const panelHeight = panel.height * geoToCanvasScale;

            const offsetCm = parseFloat(document.getElementById('offset-input').value);
            let offsetDistance = (offsetCm / 100) * geoToCanvasScale;

            // Ensure offset is always inwards by checking polygon winding order
            if (isPolygonClockwise(canvasPoints)) {
                offsetDistance = -offsetDistance;
            }

            const placementPolygon = getOffsetPolygon(canvasPoints, -offsetDistance);

            if (placementPolygon.length < 3) {
                roof.placedPanels = [];
                redrawCanvas();
                return;
            }

            const boundingBox = placementPolygon.reduce((b, p) => ({ minX: Math.min(b.minX, p.x), maxX: Math.max(b.maxX, p.x), minY: Math.min(b.minY, p.y), maxY: Math.max(b.maxY, p.y) }), { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity });

            const placedPanels = [];
             // Since it's straightened, we can iterate in a simple grid
            for (let y = boundingBox.minY; y < boundingBox.maxY - panelHeight; y += panelHeight) {
                for (let x = boundingBox.minX; x < boundingBox.maxX - panelWidth; x += panelWidth) {
                    const corners = [
                        { x: x, y: y }, { x: x + panelWidth, y: y },
                        { x: x + panelWidth, y: y + panelHeight }, { x: x, y: y + panelHeight }
                    ];

                    if (corners.every(c => isPointInPolygon(c, placementPolygon))) {
                        placedPanels.push(corners);
                    }
                }
            }

            roof.placedPanels = placedPanels; // These panels are in the transformed "detail" space
            redrawCanvas();
        }

        function getOffsetPolygon(points, offset) {
            const offsetPoints = [];
            const numPoints = points.length;
            for (let i = 0; i < numPoints; i++) {
                const p1 = points[i];
                const p2 = points[(i + 1) % numPoints];
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const len = Math.hypot(dx, dy);
                const normal = { x: -dy / len, y: dx / len };
                offsetPoints.push({
                    x1: p1.x + offset * normal.x,
                    y1: p1.y + offset * normal.y,
                    x2: p2.x + offset * normal.x,
                    y2: p2.y + offset * normal.y
                });
            }

            const newPolygon = [];
            for (let i = 0; i < numPoints; i++) {
                const line1 = offsetPoints[i];
                const line2 = offsetPoints[(i + numPoints - 1) % numPoints];
                const intersection = intersectLines(line1.x1, line1.y1, line1.x2, line1.y2, line2.x1, line2.y1, line2.x2, line2.y2);
                if (intersection) {
                    newPolygon.unshift(intersection);
                }
            }
            return newPolygon;
        }

        function intersectLines(x1, y1, x2, y2, x3, y3, x4, y4) {
            const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            if (den === 0) return null; // Parallel
            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;
            const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / den;
            return { x: x1 + t * (x2 - x1), y: y1 + t * (y2 - y1) };
        }

        function isPolygonClockwise(points) {
            let area = 0;
            for (let i = 0; i < points.length; i++) {
                const j = (i + 1) % points.length;
                area += points[i].x * points[j].y;
                area -= points[j].x * points[i].y;
            }
            return area > 0;
        }


        function isPointInPolygon(point, polygon) {
            let isInside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                if (((polygon[i].y > point.y) !== (polygon[j].y > point.y)) && (point.x < (polygon[j].x - polygon[i].x) * (point.y - polygon[i].y) / (polygon[j].y - polygon[i].y) + polygon[i].x)) {
                    isInside = !isInside;
                }
            }
            return isInside;
        }

        async function getSolarPotential(roof) {
            if (!roof) return;

            const center = { lat: roof.geoCoords[0].lat, lng: roof.geoCoords[0].lng }; // Simplified center
            const API_KEY = 'AIzaSyDmrtd9_lCHwfRIysJ4q7q0gaZvGxbmPtc';
            const url = `https://solar.googleapis.com/v1/buildingInsights:findClosest?location.latitude=${center.lat}&location.longitude=${center.lng}&requiredQuality=HIGH&key=${API_KEY}`;

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`API request failed: ${response.status}`);
                const data = await response.json();
                roof.solarData = data; // Store response on the specific roof object
                updateResults();

            } catch (error) {
                console.error(`Error fetching Solar API for roof ${roof.id}:`, error);
                alert(`太陽光発電ポテンシャルの取得に失敗しました（屋根${roof.id + 1}）。`);
            }
        }

        function updateResults() {
            let totalPanelCount = 0;
            let totalYearlyEnergy = 0;
            const panelCapacityWatts = parseFloat(document.getElementById('panel-select').value.split('-').pop());

            roofObjects.forEach(roof => {
                totalPanelCount += roof.placedPanels.length;
                if (roof.solarData && roof.solarData.solarPotential) {
                    const config = roof.solarData.solarPotential.solarPanelConfigs[0];
                    if (config) {
                        const roofEnergy = (roof.placedPanels.length * panelCapacityWatts) / (config.panelsCount * config.panelCapacityWatts) * config.yearlyEnergyDcKwh;
                        totalYearlyEnergy += roofEnergy;
                    }
                }
            });

            document.getElementById('panel-count').textContent = totalPanelCount;
            document.getElementById('yearly-energy').textContent = totalYearlyEnergy.toFixed(2);
        }

        function generatePDF() {
            const totalPanelCount = roofObjects.reduce((sum, roof) => sum + roof.placedPanels.length, 0);
            if (totalPanelCount === 0) {
                alert("Please place panels before downloading a PDF.");
                return;
            }

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();

            // Temporarily switch to overview to capture all roofs, then switch back
            const originalMode = designMode;
            designMode = 'overview';
            redrawCanvas(); // Redraw in overview mode

            doc.text("Solar Simulation Report", 20, 20);
            const canvasImage = document.getElementById('design-canvas').toDataURL('image/png', 1.0);
            doc.addImage(canvasImage, 'PNG', 15, 40, 180, 150);

            // Restore original mode
            designMode = originalMode;
            redrawCanvas();

            doc.text(`Total Panel Count: ${totalPanelCount}`, 20, 200);
            doc.text(`Total Estimated Yearly Output: ${document.getElementById('yearly-energy').textContent} kWh`, 20, 210);
            doc.addPage();
            doc.text("Aggregated Monthly Energy Production (kWh)", 20, 20);

            const chartCanvas = document.createElement('canvas');
            const aggregatedMonthlyData = new Array(12).fill(0);

            roofObjects.forEach(roof => {
                 if (roof.solarData && roof.solarData.solarPotential) {
                    const config = roof.solarData.solarPotential.solarPanelConfigs[0];
                    const panelRatio = roof.placedPanels.length / config.panelsCount;
                    roof.solarData.solarPotential.monthlyFluxes.forEach((month, i) => {
                        aggregatedMonthlyData[i] += month.kWh * panelRatio;
                    });
                 }
            });
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            new Chart(chartCanvas, {
                type: 'bar',
                data: {
                    labels: ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'],
                    datasets: [{ label: '月別発電量 (kWh)', data: aggregatedMonthlyData, backgroundColor: 'rgba(54, 162, 235, 0.6)' }]
                },
                options: { animation: { onComplete: () => {
                    doc.addImage(chartCanvas.toDataURL('image/png', 1.0), 'PNG', 20, 40, 170, 85);
                    doc.save('simulation_report.pdf');
                }}}
            });
        }

        window.addEventListener('DOMContentLoaded', () => {
            document.getElementById('to-design-btn').addEventListener('click', toDesignView);
            document.getElementById('auto-correct-btn').addEventListener('click', autoCorrectPolygon);
            document.getElementById('auto-place-btn').addEventListener('click', () => {
                if (selectedRoofIndex !== -1) {
                    autoPlacePanels();
                    getSolarPotential(roofObjects[selectedRoofIndex]);
                } else {
                    alert("Please select a roof to place panels on.");
                }
            });
            document.getElementById('download-pdf-btn').addEventListener('click', generatePDF);

            document.getElementById('back-to-overview-btn').addEventListener('click', () => {
                designMode = 'overview';
                selectedRoofIndex = -1;
                document.getElementById('back-to-overview-btn').style.display = 'none';
                redrawCanvas();
            });

            const canvas = document.getElementById('design-canvas');
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseUp);
        });
    </script>
</body>
</html>